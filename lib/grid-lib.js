/*
 * From https://www.redblobgames.com/grids/parts/
 * Copyright 2021 Red Blob Games <redblobgames@gmail.com>
 * License: Apache-2.0 <http://www.apache.org/licenses/LICENSE-2.0.html>
 */

/* This code was partially generated by Haxe, but then I manually cleaned it up */

const SQRT_3_2 = Math.sqrt(3) / 2;

export class FiniteGrid {
  constructor(grid, shape) {
    this.grid = grid;
    this.tiles = shape;
    this.edges = [];
    this.vertices = [];
    this.lookupTile = new Map();
    this.lookupEdge = new Map();
    this.lookupVertex = new Map();

    for (let tile of this.tiles) {
      this.lookupTile.set(tile.key, tile);

      for (let edge of this.grid.borders(tile)) {
        if (!this.lookupEdge.has(edge.key)) {
          this.lookupEdge.set(edge.key, edge);
          this.edges.push(edge);
        }
      }

      for (let vertex of this.grid.corners(tile)) {
        if (!this.lookupVertex.has(vertex.key)) {
          this.lookupVertex.set(vertex.key, vertex);
          this.vertices.push(vertex);
        }
      }
    }
  }

  vertexToScreen(vertex) {
    return this.grid.vertexToScreen(vertex);
  }
  neighbors(tile) {
    return FiniteGrid.filterBy(this.grid.neighbors(tile), this.lookupTile);
  }
  joins(edge) {
    return FiniteGrid.filterBy(this.grid.joins(edge), this.lookupTile);
  }
  touches(vertex) {
    return FiniteGrid.filterBy(this.grid.touches(vertex), this.lookupTile);
  }
  borders(tile) {
    return FiniteGrid.filterBy(this.grid.borders(tile), this.lookupEdge);
  }
  continues(edge) {
    return FiniteGrid.filterBy(this.grid.continues(edge), this.lookupEdge);
  }
  protrudes(vertex) {
    return FiniteGrid.filterBy(this.grid.protrudes(vertex), this.lookupEdge);
  }
  corners(tile) {
    return FiniteGrid.filterBy(this.grid.corners(tile), this.lookupVertex);
  }

  endpoints(edge) {
    return FiniteGrid.filterBy(this.grid.endpoints(edge), this.lookupVertex);
  }

  adjacent(vertex) {
    return FiniteGrid.filterBy(this.grid.adjacent(vertex), this.lookupVertex);
  }

  static rectangularShape(minQ, minR, maxQ, maxR) {
    let tiles = [];
    for (let q = minQ; q <= maxQ; q++) {
      for (let r = minR; r <= maxR; r++) {
        tiles.push(new Tile(q, r));
      }
    }
    return tiles;
  }

  static hexagonalShape(size) {
    let tiles = [];
    for (let q = 0; q <= 2 * size; q++) {
      for (let r = 0; r <= 2 * size; r++) {
        if (size <= q + r && q + r <= 3 * size) {
          tiles.push(new Tile(q, r));
        }
      }
    }
    return tiles;
  }

  static parallelogramShapeWithTriangles(minQ, minR, maxQ, maxR) {
    let tiles = [];
    for (let q = minQ; q <= maxQ; q++) {
      for (let r = minR; r <= maxR; r++) {
        tiles.push(new Tile(q, r, "L"));
        tiles.push(new Tile(q, r, "R"));
      }
    }
    return tiles;
  }

  static triangleShapeWithTriangles(size) {
    let tiles = [];
    for (let q = 0; q <= size; q++) {
      for (let r = 0; r <= size; r++) {
        if (q + r <= size) {
          tiles.push(new Tile(q, r, "L"));
        }
        if (q + r < size) {
          tiles.push(new Tile(q, r, "R"));
        }
      }
    }
    return tiles;
  }
  static filterBy(array, lookupMap) {
    return array.filter(element => lookupMap.has(element.key));
  }
}

export class GridCoordinate {
  constructor(q, r, s = '') {
    this.q = q;
    this.r = r;
    this.s = s;
  }
  get label() {
    let { q, r, s } = this;
    return `${q},${r}${s?',':''}${s}`;
  }
  get key() {
    return `${this.type}:${this.label}`;
  }
  toString() {
    return this.label;
  }
}

export class Tile extends GridCoordinate {
  type = 'Tile'
}

export class Edge extends GridCoordinate {
  type = 'Edge'
}

export class Vertex extends GridCoordinate {
  type = 'Vertex'
}

export class ScreenCoordinate {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  equals(p) {
    if (this.x == p.x) {
      return this.y == p.y;
    } else {
      return false;
    }
  }
  toString() {
    return this.x + "," + this.y;
  }
  length_squared() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.length_squared());
  }
  normalize() {
    let d = this.length();
    return new ScreenCoordinate(this.x / d, this.y / d);
  }
  scale(d) {
    return new ScreenCoordinate(this.x * d, this.y * d);
  }
  rotateLeft() {
    return new ScreenCoordinate(this.y, -this.x);
  }
  rotateRight() {
    return new ScreenCoordinate(-this.y, this.x);
  }
  add(p) {
    return new ScreenCoordinate(this.x + p.x, this.y + p.y);
  }
  subtract(p) {
    return new ScreenCoordinate(this.x - p.x, this.y - p.y);
  }
  dot(p) {
    return this.x * p.x + this.y * p.y;
  }
  cross(p) {
    return this.x * p.y - this.y * p.x;
  }
  distance(p) {
    return this.subtract(p).length();
  }
}

export class SquareGrid {
  constructor(scale, originTile) {
    this.scale = scale;
    this.originTile = originTile;
    this.tiles = [originTile]
    this.edges = ['W', 'N']
    this.vertexes = ['']

  }



  vertexToScreen(vertex) {
    return new ScreenCoordinate(vertex.q * this.scale,
      vertex.r * this.scale);
  }

  neighbors(tile) {
    const { q, r } = tile;
    return [
          new Tile(q, r - 1),
          new Tile(q - 1, r),
          new Tile(q, r + 1),
          new Tile(q + 1, r),
      ];
  }

  borders(tile) {
    const { q, r } = tile;
    return [
          new Edge(q, r, 'N'),
          new Edge(q, r, 'W'),
          new Edge(q, r + 1, 'N'),
          new Edge(q + 1, r, 'W'),
      ];
  }

  corners(tile) {
    const { q, r } = tile;
    return [
          new Vertex(q, r),
          new Vertex(q, r + 1),
          new Vertex(q + 1, r + 1),
          new Vertex(q + 1, r),
      ];
  }

  joins(edge) {
    const { q, r, s } = edge;
    switch (s) {
      case 'N':
        return [new Tile(q, r - 1), new Tile(q, r)];
      case 'W':
        return [new Tile(q, r), new Tile(q - 1, r)];
    }
    return [];
  }

  continues(edge) {
    const { q, r, s } = edge;
    switch (edge.s) {
      case 'N':
        return [new Edge(q - 1, r, 'N'), new Edge(q + 1, r, 'N')];
      case 'W':
        return [new Edge(q, r - 1, 'W'), new Edge(q, r + 1, 'W')];
    }
    return [];
  }

  endpoints(edge) {
    const { q, r, s } = edge;
    switch (s) {
      case 'N':
        return [new Vertex(q + 1, r), new Vertex(q, r)];
      case 'W':
        return [new Vertex(q, r), new Vertex(q, r + 1)];
    }
    return [];
  }

  touches(vertex) {
    const { q, r } = vertex;
    return [
          new Tile(q, r),
          new Tile(q, r - 1),
          new Tile(q - 1, r - 1),
          new Tile(q - 1, r),
      ];
  }

  protrudes(vertex) {
    const { q, r } = vertex;
    return [
          new Edge(q, r, 'W'),
          new Edge(q, r, 'N'),
          new Edge(q, r - 1, 'W'),
          new Edge(q - 1, r, 'N'),
      ];
  }

  adjacent(vertex) {
    const { q, r } = vertex;
    return [
          new Vertex(q, r + 1),
          new Vertex(q + 1, r),
          new Vertex(q, r - 1),
          new Vertex(q - 1, r),
      ];
  }
}








export class TriangleGrid {
  tile_s = ['L', 'R']
  edge_s = ['E', 'N', 'W']
  vertex_s = ['']

  constructor(scale) {
    this.scale = scale;
  }
  vertexToScreen(vertex) {
    let x = (this.scale * (vertex.q + vertex.r * 0.5)) / SQRT_3_2;
    let y = this.scale * vertex.r;
    return new ScreenCoordinate(x, y);
  }
  neighbors(tile) {
    const { q, r, s } = tile;
    switch (s) {
      case 'L':
        return [
              new Tile(q, r, 'R'),
              new Tile(q, r - 1, 'R'),
              new Tile(q - 1, r, 'R'),
          ];
      case 'R':
        return [
              new Tile(q, r + 1, 'L'),
              new Tile(q + 1, r, 'L'),
              new Tile(q, r, 'L'),
          ];
    }
    return [];
  }
  borders(tile) {
    const { q, r, s } = tile;
    switch (s) {
      case 'L':
        return [new Edge(q, r, 'E'), new Edge(q, r, 'N'), new Edge(q, r, 'W')];
      case 'R':
        return [
              new Edge(q, r + 1, 'N'),
              new Edge(q + 1, r, 'W'),
              new Edge(q, r, 'E'),
          ];
    }
    return [];
  }
  corners(tile) {
    const { q, r, s } = tile;
    switch (s) {
      case 'L':
        return [new Vertex(q, r + 1), new Vertex(q + 1, r), new Vertex(q, r)];
      case 'R':
        return [
              new Vertex(q + 1, r + 1),
              new Vertex(q + 1, r),
              new Vertex(q, r + 1),
          ];
    }
    return [];
  }
  joins(edge) {
    const { q, r, s } = edge;
    switch (s) {
      case 'E':
        return [new Tile(q, r, 'R'), new Tile(q, r, 'L')];
      case 'N':
        return [new Tile(q, r, 'L'), new Tile(q, r - 1, 'R')];
      case 'W':
        return [new Tile(q, r, 'L'), new Tile(q - 1, r, 'R')];
    }
    return [];
  }
  continues(edge) {
    const { q, r, s } = edge;
    switch (s) {
      case 'E':
        return [new Edge(q + 1, r - 1, 'E'), new Edge(q - 1, r + 1, 'E')];
      case 'N':
        return [new Edge(q + 1, r, 'N'), new Edge(q - 1, r, 'N')];
      case 'W':
        return [new Edge(q, r + 1, 'W'), new Edge(q, r - 1, 'W')];
    }
    return [];
  }
  endpoints(edge) {
    const { q, r, s } = edge;
    switch (s) {
      case 'E':
        return [new Vertex(q + 1, r), new Vertex(q, r + 1)];
      case 'N':
        return [new Vertex(q + 1, r), new Vertex(q, r)];
      case 'W':
        return [new Vertex(q, r + 1), new Vertex(q, r)];
    }
    return [];
  }
  touches(vertex) {
    const { q, r } = vertex;
    return [
          new Tile(q - 1, r, 'R'),
          new Tile(q, r, 'L'),
          new Tile(q, r - 1, 'R'),
          new Tile(q, r - 1, 'L'),
          new Tile(q - 1, r - 1, 'R'),
          new Tile(q - 1, r, 'L'),
      ];
  }
  protrudes(vertex) {
    const { q, r } = vertex;
    return [
          new Edge(q, r, 'W'),
          new Edge(q, r, 'N'),
          new Edge(q, r - 1, 'E'),
          new Edge(q, r - 1, 'W'),
          new Edge(q - 1, r, 'N'),
          new Edge(q - 1, r, 'E'),
      ];
  }
  adjacent(vertex) {
    const { q, r } = vertex;
    return [
          new Vertex(q, r + 1),
          new Vertex(q + 1, r),
          new Vertex(q + 1, r - 1),
          new Vertex(q, r - 1),
          new Vertex(q - 1, r),
          new Vertex(q - 1, r + 1),
      ];
  }
}

export class HexagonGrid {
  tile_s = ['']
  edge_s = ['NE', 'NW', 'W']
  vertex_s = ['N', 'S']

  constructor(size) {
    this.scale = size;
  }
  vertexToScreen(vertex) {
    const { q, r, s } = vertex;
    let x = this.scale * (q + r / 2 + 1 / 2) / SQRT_3_2;
    let y = this.scale * (r + (s === 'S' ? 7 / 6 : -1 / 6));
    return new ScreenCoordinate(x, y);
  }
  neighbors(tile) {
    const { q, r } = tile;
    return [
          new Tile(q, r + 1),
          new Tile(q + 1, r),
          new Tile(q + 1, r - 1),
          new Tile(q, r - 1),
          new Tile(q - 1, r),
          new Tile(q - 1, r + 1),
      ];
  }
  borders(tile) {
    const { q, r } = tile;
    return [
          new Edge(q, r, 'NE'),
          new Edge(q, r, 'NW'),
          new Edge(q, r, 'W'),
          new Edge(q - 1, r + 1, 'NE'),
          new Edge(q, r + 1, 'NW'),
          new Edge(q + 1, r, 'W'),
      ];
  }
  corners(tile) {
    const { q, r } = tile;
    return [
          new Vertex(q, r, 'N'),
          new Vertex(q, r - 1, 'S'),
          new Vertex(q - 1, r + 1, 'N'),
          new Vertex(q, r, 'S'),
          new Vertex(q, r + 1, 'N'),
          new Vertex(q + 1, r - 1, 'S'),
      ];
  }
  joins(edge) {
    const { q, r, s } = edge;
    switch (s) {
      case 'NE':
        return [
           new Tile(q + 1, r - 1),
           new Tile(q, r)
       ];
      case 'NW':
        return [
           new Tile(q, r),
           new Tile(q, r - 1)
       ];
      case 'W':
        return [
           new Tile(q, r),
           new Tile(q - 1, r)
       ];
    }
    return [];
  }
  continues(_edge) {
    return [];
  }
  endpoints(edge) {
    const { q, r, s } = edge;
    switch (s) {
      case 'NE':
        return [
           new Vertex(q + 1, r - 1, 'S'),
           new Vertex(q, r, 'N')
       ];
      case 'NW':
        return [
           new Vertex(q, r, 'N'),
           new Vertex(q, r - 1, 'S')
       ];
      case 'W':
        return [
           new Vertex(q, r - 1, 'S'),
           new Vertex(q - 1, r + 1, 'N')
       ];
    }
    return [];
  }

  touches(vertex) {
    const { q, r, s } = vertex;
    switch (s) {
      case 'N':
        return [
           new Tile(q + 1, r - 1),
           new Tile(q, r),
           new Tile(q, r - 1)
       ];
      case 'S':
        return [
           new Tile(q, r),
           new Tile(q, r + 1),
           new Tile(q - 1, r + 1)
       ];
    }
    return [];
  }

  protrudes(vertex) {
    const { q, r, s } = vertex;
    switch (s) {
      case 'N':
        return [
           new Edge(q, r, 'NE'),
           new Edge(q + 1, r - 1, 'W'),
           new Edge(q, r, 'NW'),
       ];
      case 'S':
        return [
           new Edge(q, r + 1, 'NW'),
           new Edge(q - 1, r + 1, 'NE'),
           new Edge(q, r + 1, 'W'),
       ];
    }
    return [];
  }

  adjacent(vertex) {
    const { q, r, s } = vertex;
    switch (s) {
      case 'N':
        return [
              new Vertex(q + 1, r - 2, 'S'),
              new Vertex(q, r - 1, 'S'),
              new Vertex(q + 1, r - 1, 'S'),
          ];
      case 'S':
        return [
              new Vertex(q - 1, r + 1, 'N'),
              new Vertex(q - 1, r + 2, 'N'),
              new Vertex(q, r + 1, 'N'),
          ];
    }
    return [];
  }
}
