<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Line drawing on a grid</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="preload" as="image" href="/img/transparent-blob.png">
  <link rel="canonical" href="https://www.redblobgames.com/grids/line-drawing.html">
  <link rel="alternate" type="application/atom+xml" title="Blobs in Games - Atom" href="https://simblob.blogspot.com/feeds/posts/default">
  <meta name="twitter:creator" content="@redblobgames">
  <meta name="theme-color" content="hsl(0,50%,45%)">
  <meta name="verify-v1" content="82b+h1+tgwLrcTqTiJrqquMvoFVBwMwY11dx63m01zk=">
  <style>
    :root {
      --hue: 0;
      --bgurl: url("/img/transparent-blob.png")
    }

    /*! CSS Copyright 2007-2020 by amitp@cs.stanford.edu (Amit J. Patel)  */
    /*! I don't mind if you copy my stylesheet.  However, I'd appreciate it if you gave me credit. */
    body {
      --serif: "Iowan Old Style", Cambria, Georgia, serif;
      --sans-serif: "Avenir Next", Candara, Ubuntu, "Fira Sans", system-ui, "Segoe UI", sans-serif;
      --monospace: "Roboto Mono", "Cascadia Mono", Consolas, monospace, "Segoe UI Symbol", Symbol;
      --body-width: calc(100vw - 2.25rem);
      --font-size: calc(0.625rem + 1vw);
      --line-height: calc(1.5 * var(--font-size));
      font-family: var(--sans-serif);
      font-size: var(--font-size);
      line-height: 1.5em;
      min-height: 95%
    }

    @media (min-width: 34.375em) {
      body {
        --body-width: min(20.6rem + 33vw, 41.25rem);
        --font-size: calc(var(--body-width) / 33)
      }
    }

    main {
      font-family: var(--serif)
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    figcaption,
    .sans-serif {
      font-family: var(--sans-serif)
    }

    tt,
    code,
    kbd,
    samp,
    pre {
      font-family: var(--monospace);
      font-size: 0.8em
    }

    #table-of-contents {
      background-color: #fff;
      padding-left: 1em;
      width: 18em;
      float: right
    }

    #table-of-contents:after {
      clear: right
    }

    nav,
    #table-of-contents {
      font-family: var(--sans-serif);
      font-size: calc(var(--font-size) / 1.25)
    }

    @media screen {

      header,
      section>h2 {
        text-shadow: 0px 2px 5px rgba(0, 0, 0, 0.8);
        text-rendering: optimizeLegibility
      }
    }

    h1 {
      font-size: 2.0em;
      margin: 0;
      line-height: calc(1.5 * var(--line-height))
    }

    h1 .subheading {
      font-size: 0.5em;
      line-height: var(--line-height)
    }

    sup,
    sub {
      position: relative;
      vertical-align: baseline;
      font-size: 0.75em;
      line-height: 0;
      padding-left: 0.125em
    }

    sup {
      top: -0.5em
    }

    sub {
      bottom: -0.25em
    }

    * {
      box-sizing: border-box
    }

    html,
    body {
      margin: 0;
      padding: 0
    }

    html {
      background-color: #e4e4e0;
      color: #000
    }

    body {
      background-color: #fff;
      color: #333
    }

    header {
      display: block;
      text-align: center
    }

    header>h1 {
      padding-top: var(--line-height)
    }

    @media screen {

      .colored-background,
      header,
      footer,
      .divider,
      section>h2 {
        color: #fff;
        background-color: hsl(var(--hue), 50%, 45%);
        background-image: var(--bgurl), var(--bgurl);
        background-position: 0 0, 16px 16px;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale
      }

      .colored-background a,
      header a,
      footer a,
      .divider a,
      section>h2 a {
        color: hsl(var(--hue), 40%, 90%)
      }
    }

    footer a,
    .divider a {
      text-decoration: underline
    }

    main {
      margin-left: 0;
      margin-right: 0;
      padding-left: 0;
      padding-right: 0
    }

    section {
      margin: var(--line-height) 0
    }

    section>*,
    .comments {
      width: var(--body-width);
      max-width: 100%
    }

    @media screen {

      .comments,
      .below-divider {
        background-color: #e4e4e0
      }
    }

    .comments {
      padding-bottom: 1.25rem;
      font-size: 1.0rem
    }

    .comments .comment-author {
      text-shadow: 1px 1px 3px #fff
    }

    section>h2 {
      --h2-margin: 3em;
      --h2-padding: 0.5em;
      margin: var(--line-height) auto;
      padding: calc(var(--line-height) / 2 - 1px) 0;
      font-size: 1.25em;
      width: calc(2 * var(--h2-margin) + var(--body-width));
      max-width: 100%
    }

    section>h2>span {
      display: inline-block;
      margin-left: var(--h2-margin)
    }

    section>h2 a.anchor {
      float: right;
      width: var(--h2-margin);
      padding-right: var(--h2-padding);
      text-align: center;
      color: hsl(var(--hue), 50%, 45%)
    }

    section>h2:hover a.anchor {
      color: hsl(var(--hue), 20%, 80%)
    }

    h3 {
      --h2-margin: 3em;
      margin: var(--line-height) auto;
      font-size: 1.125em
    }

    h3 a.anchor {
      float: right;
      width: var(--h2-margin);
      padding-right: 0.5em;
      text-align: center;
      color: hsl(var(--hue), 20%, 80%)
    }

    @media (min-width: 34.375em) {
      h3 a.anchor {
        margin-right: calc(0em - var(--h2-margin))
      }
    }

    h4 a.anchor,
    h5 a.anchor,
    h6 a.anchor {
      padding-left: 1em;
      color: hsl(var(--hue), 20%, 80%)
    }

    h3:hover,
    h4:hover a.anchor,
    h5:hover a.anchor,
    h6:hover a.anchor {
      color: hsl(var(--hue), 50%, 40%)
    }

    header nav {
      display: block
    }

    header nav ul {
      display: flex;
      flex-flow: row wrap;
      justify-content: center;
      line-height: 1.0;
      margin: 0
    }

    header nav ul li {
      display: inline-block;
      padding: 0.1em 0.3em;
      text-align: center;
      flex: 0 0 4em;
      align-self: center;
      white-space: nowrap
    }

    header nav ul li a {
      display: block;
      font-weight: bold;
      text-decoration: none
    }

    header nav ul li:hover {
      background-color: rgba(0, 0, 0, 0.5);
      font-weight: bold
    }

    header,
    .divider,
    section>h2 {
      border-bottom: 1px solid #000
    }

    .divider,
    section>h2 {
      border-top: 1px solid #000
    }

    .divider {
      min-height: calc(2 * var(--line-height));
      text-align: center
    }

    .below-divider {
      padding-top: var(--line-height);
      border-bottom: 1px solid black
    }

    .below-divider>p:first-child {
      font-size: 1.25em;
      text-align: center;
      margin-top: 0
    }

    footer {
      --footer-padding-y: calc(var(--line-height) / 2);
      --footer-padding-x: var(--font-size);
      padding: var(--footer-padding-y) var(--footer-padding-x);
      border-top: 1px solid #000
    }

    footer>div>address {
      display: block
    }

    footer>div>* {
      text-align: center
    }

    @media (min-width: 50em) {
      footer>div {
        margin: 0 auto;
        display: flex;
        flex-flow: row wrap;
        justify-content: center;
        max-width: calc(2 * var(--body-width));
        width: calc(100vw - 2 * var(--footer-padding-x))
      }

      footer>div>address {
        flex: 0 1 20em;
        align-self: center;
        text-align: left
      }

      footer>div>div {
        flex: 1 1 20em;
        align-self: center;
        text-align: right
      }

      footer>div>div>p,
      footer>div>div>div {
        margin-top: 0
      }
    }

    h2:target {
      animation: target-attention 0.4s 1;
      font-size: 2.0em
    }

    @keyframes target-attention {
      0% {
        transform: scale(1.1)
      }

      100% {
        transform: scale(1.1)
      }
    }

    div:target {
      border: 1px dashed #888
    }

    kbd kbd {
      padding: 0.1em 0.4em;
      margin: 0 0.1em 0.2em 0.1em;
      font-size: 0.75em;
      white-space: nowrap;
      background-color: #ddd;
      color: #242;
      border: 1px solid rgba(0, 0, 0, 0.2);
      border-radius: 0.2em;
      box-shadow: inset 0 0 1px 1px #fff, 0 2px 0 rgba(0, 0, 0, 0.3)
    }

    samp,
    kbd {
      background-color: #f3f3f2
    }

    code,
    samp {
      color: #442
    }

    kbd {
      margin: 0 0.4em;
      color: #252
    }

    section li::marker {
      font-family: var(--sans-serif);
      color: hsl(var(--hue), 50%, 40%)
    }

    img {
      max-width: 100%;
      height: auto;
      -ms-interpolation-mode: bicubic
    }

    section figcaption {
      font-size: 0.75em;
      line-height: 1.1;
      text-align: center
    }

    a {
      color: hsl(var(--hue), 50%, 45%);
      text-decoration: none
    }

    a:hover {
      text-decoration: underline
    }

    :focus {
      outline-color: hsl(var(--hue), 50%, 45%)
    }

    .draft {
      font-family: var(--serif);
      font-size: calc(4 * var(--font-size));
      letter-spacing: -0.1em;
      color: #eee;
      opacity: 0.5;
      text-align: center;
      transform: rotate(-5deg);
      line-height: 1.0;
      position: absolute;
      top: 0;
      height: 0;
      left: 25%;
      width: 50%;
      pointer-events: none
    }

    @media (min-width: 34.375em) {

      section p,
      section li {
        hanging-punctuation: first last
      }

      p,
      nav,
      figure,
      td,
      th,
      abbr,
      acronym,
      code,
      kbd,
      samp,
      tt,
      var,
      pre {
        hyphens: auto;
        -webkit-hyphens: auto
      }
    }

    .w-auto,
    section>.w-auto {
      width: auto
    }

    .w-full,
    section>.w-full {
      width: 100%
    }

    .select-none {
      user-select: none;
      -webkit-user-select: none
    }

    .text-left {
      text-align: left
    }

    .text-center {
      text-align: center
    }

    .text-right {
      text-align: right
    }

    .text-sm {
      font-size: 0.875em
    }

    .font-sans {
      font-family: var(--sans-serif)
    }

    .font-serif {
      font-family: var(--serif)
    }

    .font-mono {
      font-family: var(--monospace)
    }

    p,
    figure,
    ul,
    ol {
      margin: var(--line-height) 0
    }

    header>*,
    section>*,
    footer>*,
    main>address,
    .comments {
      margin-left: auto;
      margin-right: auto
    }

    figure {
      text-align: center
    }

    li>ul,
    li>ol {
      margin-top: 0;
      margin-bottom: 0
    }

    figure img,
    figure svg,
    figure canvas {
      max-width: 100%
    }

    dt {
      font-weight: bold
    }

    pre {
      width: var(--body-width);
      max-width: 100%;
      line-height: 1.4;
      overflow: auto;
      border-top: 1px solid #ccc;
      border-bottom: 1px solid #ccc;
      border-left-width: 0;
      border-right-width: 0
    }

    pre::-webkit-scrollbar {
      height: 1em
    }

    pre::-webkit-scrollbar-thumb:horizontal {
      border-radius: 0.5em;
      background: rgba(0, 0, 0, 0.4)
    }

    pre.simple,
    .comments pre {
      overflow: auto;
      width: calc(var(--body-width) * 1.2);
      border: none;
      background: transparent;
      background-color: transparent;
      box-shadow: none
    }

    pre.snippet,
    pre.src {
      border-top-style: dashed;
      border-bottom-style: dashed
    }

    section>pre:only-child {
      padding-bottom: var(--font-size);
      border-bottom: 1px solid rgba(0, 0, 0, 0.5)
    }

    blockquote {
      font-style: italic
    }

    table.standard {
      font-family: var(--sans-serif);
      font-size: 0.875em;
      border: 2px solid white;
      border-collapse: collapse;
      overflow-x: auto
    }

    table.standard th {
      background-color: #e8e8e3;
      border: 2px solid white;
      padding: 0 0.5em
    }

    table.standard td {
      background-color: #fff;
      border: 1px solid #f3f3f2;
      border-right-color: #babaab;
      padding: 0 0.5em
    }

    table.standard thead {
      border-bottom: 2px solid #babaab
    }

    table.standard thead th {
      background: linear-gradient(to top, #e8e8e3, #f4f4f1, #fafaf9)
    }

    aside,
    p.note,
    div.note>p {
      width: calc(--body-width - 2em);
      padding: 1em;
      background: #eee;
      border: 1px solid #ddd;
      box-shadow: 0 8px 6px -6px rgba(0, 0, 0, 0.4)
    }

    tt,
    code {
      padding: 0 2px
    }

    main>address,
    section>address,
    section>time {
      display: block;
      width: var(--body-width);
      max-width: 100%;
      font-family: var(--sans-serif);
      text-align: right
    }

    form {
      margin: 0
    }

    input {
      accent-color: hsl(var(--hue), 50%, 50%)
    }

    input[type="text"] {
      max-width: 100%;
      border: 1px solid rgba(0, 0, 0, 0.7);
      background-color: #f8f8f4;
      color: #000;
      text-align: center;
      font-weight: bold
    }

    input[type="text"]:focus {
      background-color: #fffff4
    }

    input::-webkit-input-placeholder {
      color: #aaa
    }

    input::-moz-placeholder {
      color: #aaa
    }

    input[type="search"][name="q"] {
      box-shadow: inset 0 0.1em 0.3em 0 rgba(0, 0, 0, 0.5);
      border-radius: 0.6em;
      padding: 0.3em 0.6em;
      border-width: 0
    }

    .TODO {
      color: #bf4040;
      background: #e8e3e3;
      border: 1px solid #bf4040;
      margin-left: 0.5ex
    }

    .DONE {
      color: #4040bf;
      background: #e3e3e8;
      border: 1px solid #4040bf
    }

    .src .constant {
      font-style: oblique
    }

    .src .comment-delimiter,
    .src .nxml-comment-delimiter {
      color: #4488ff
    }

    .src .comment,
    .src .nxml-comment-content {
      color: #006699
    }

    .src .builtin {
      color: #508b20
    }

    .src .warning {
      color: #cc0000
    }

    .src .function-name {
      color: #268bd2;
      font-weight: bold
    }

    .src .variable-name {
      font-weight: bold;
      color: #5c3d5c
    }

    .src .type {
      color: #6c71c4
    }

    .src .constant-face {
      color: #d33682
    }

    .src .doc {
      color: #666666;
      background-color: #e2e6e8
    }

    .src .string {
      color: #888888
    }

    .src .preprocessor {
      color: #859900
    }

    .src .negation-char,
    .src .sh-escaped-newline {
      color: #ff0000
    }

    .src .todo {
      color: #ffffff;
      background: #dc322f
    }

    .src .note {
      color: #ffffff;
      background: #2aa198
    }

    .src .hack {
      color: #ffffff;
      background: #859900
    }

    .src .paren {
      color: #a0a090;
      font-weight: bold
    }

    .src .keyword {
      color: #679;
      font-weight: bold
    }

    .src .minor-control-construct {
      color: #406abf;
      font-weight: bold
    }

    .src .major-control-construct {
      color: #bf4040
    }

    .src-cpp .constant {
      color: #999999
    }

    .src-emacs-lisp .paren {
      color: #c9c9c4
    }

    .src-sh .string,
    .src-sh .comment {
      color: inherit
    }

    .src-python .highlight-indentation {
      border-right: 2px solid #eeeeee
    }

    .src-css .css-selector {
      color: #478547
    }

    .src-css .css-property {
      color: #406abf
    }

    .src-xml .nxml-element-prefix {
      color: #bf40bf
    }

    .src-xml .nxml-element-local-name {
      color: #406abf;
      font-weight: normal
    }

    .src-xml .nxml-attribute-local-name {
      color: #478547
    }

    .src-xml .nxml-element-colon {
      color: #a3adc2
    }

    .src-xml .nxml-tag-delimiter,
    .src-xml .nxml-tag-slash {
      color: #9cabc9;
      font-weight: bold
    }

    table.standard td.left,
    table.standard th.left {
      text-align: left
    }

    table.standard td.center,
    table.standard th.center {
      text-align: center
    }

    table.standard td.right,
    table.standard th.right {
      text-align: right
    }

    @media screen {
      *[class^="section-number"] {
        color: hsl(var(--hue), 20%, 50%)
      }

      h2 .section-number {
        display: inline-block;
        margin-left: 0;
        padding-left: 0.5em;
        text-align: center;
        width: var(--h2-margin);
        color: hsl(var(--hue), 50%, 80%)
      }

      h2 .section-number+span {
        margin-left: 0
      }

      h3 .section-number {
        float: left;
        text-align: center;
        width: 2em;
        margin-right: 0.5em;
        color: hsl(var(--hue), 25%, 90%);
        background: hsl(var(--hue), 50%, 50%);
        border-radius: 0.25em;
        text-shadow: 0px 2px 5px rgba(0, 0, 0, 0.8)
      }
    }

    @media screen and (min-width: 34.375em) {
      h3 .section-number {
        background: url(/img/svg-blob-mini.svg) no-repeat center center;
        background-size: 2em 2em;
        height: 2em;
        margin-left: -2.5em;
        margin-top: -0.3em;
        padding-top: 0.3em
      }
    }

    .print-endnote {
      display: none
    }

    @media print {
      @page {
        margin: 1in
      }

      body {
        --font-size: 13pt;
        --body-width: 100vw;
        --serif: "Book Antiqua", "Times New Roman", serif;
        --sans-serif: "Helvetica", sans-serif;
        --monospace: "Courier", "Courier New", monospace
      }

      h2,
      h3 {
        page-break-after: avoid
      }

      figure {
        page-break-inside: avoid
      }

      p,
      li {
        orphans: 5;
        widows: 5
      }

      section p a,
      section li a {
        text-decoration: underline
      }

      header nav,
      .comments {
        display: none
      }

      .print-endnote {
        display: unset
      }

      .print-endnote li {
        list-style-type: none;
        word-break: break-all
      }

      .print-endnote img {
        width: 2.5em;
        vertical-align: bottom
      }
    }

    @media print {
      header::before {
        position: absolute;
        right: 0;
        top: 0;
        content: url(http://chart.apis.google.com/chart?chs=120x120&cht=qr&chl=https%3A%2F%2Fwww.redblobgames.com%2Fgrids%2Fline-drawing.html);
      }
    }

    svg {
      pointer-events: none;
    }

    .grid rect {
      fill: hsl(0, 10%, 85%);
    }

    .grid rect.wall {
      fill: hsl(30, 30%, 60%);
    }

    .linedraw rect {
      fill: hsl(0, 30%, 50%);
      fill-opacity: 0.3;
      stroke: hsl(0, 30%, 50%);
      stroke-width: 0.06px;
    }

    .endpoints circle {
      cursor: move;
      touch-action: none;
      pointer-events: all;
    }

    .endpoints circle.invisible {
      fill: none;
    }

    .endpoints circle.visible {
      fill: hsl(0, 50%, 50%);
      stroke: hsl(0, 100%, 100%);
      stroke-width: 0.04px;
    }

    .track {
      fill: none;
      stroke: hsl(0, 0%, 100%);
      stroke-opacity: 0.5;
      stroke-width: 0.7px;
    }

    #diagram-supercover .track {
      stroke-opacity: 1.0;
      stroke-width: 0.1px;
    }

    .midpoints circle {
      fill: hsl(0, 100%, 70%);
      stroke: hsl(0, 100%, 100%);
      stroke-width: 0.04px;
    }

    .midpoints text {
      fill: black;
      font: 0.6px sans-serif;
    }

    #line-rounding .midpoints text {
      fill: none;
    }

    .interpolation circle {
      fill: hsl(0, 100%, 70%);
      stroke: hsl(0, 100%, 100%);
      stroke-width: 0.04px;
    }

    *[data-format] {
      white-space: pre-wrap;
      font-family: "Source Code Pro", sans-serif;
    }

    .draggable {
      cursor: col-resize;
      touch-action: pan-y;
      /* Expand the region where mouse/touch events are grabbed */
      padding: 0.5rem;
      margin: -0.5rem;
    }

    .draggable span {
      font-weight: bold;
      line-height: 1.8;
      background-color: #eee;
      box-shadow: 0 0 0.25em hsla(0, 0%, 0%, 0.3);
      border-radius: 0.25em;
      padding: 0.125em 0.25em;
      transition: background-color 0.15s, box-shadow 0.15s;
    }

    .draggable:hover span,
    .dragging span {
      box-shadow: 0 0 0.25em hsla(0, 50%, 50%, 0.5);
    }

    .dragging span {
      background-color: hsl(0, 50%, 80%);
    }
  </style>
  <!-- <script type="module" src="cdn_modules/d3@7.4.4/d3.js"></script> -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.4.4/d3.min.js" integrity="sha512-hnFpvCiJ8Fr1lYLqcw6wLgFUOEZ89kWCkO+cEekwcWPIPKyknKV1eZmSSG3UxXfsSuf+z/SgmiYB1zFOg3l2UQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <!-- <script src="/ECS/linedrawing-helpers.js" type="text/javascript" charset="utf-8"></script> -->

  <script>
    function $l(s, e, d) {
      d = document;
      if (d.location.hostname != 'localhost') {
        e = d.createElement('script');
        e.async = true;
        e.src = s;
        e.dataset.timestamp = +new Date();
        d.body.appendChild(e)
      }
    }
  </script>
</head>

<body class="gameprog">
  <header>
    <h1>Line drawing on a grid</h1>
    <div class="subheading">
      from <a href="https://www.redblobgames.com/">Red Blob Games</a></div>
    <nav>
      <form action="https://www.google.com/search">
        <ul>
          <li><a href="https://www.redblobgames.com/">Home</a></li>
          <li><a href="https://simblob.blogspot.com/">Blog</a></li>
          <li><a href="https://pinboard.in/u:amitp/t:gamedev/">Links</a></li>
          <li><a href="https://twitter.com/redblobgames">Twitter</a></li>
          <li><a rel="me" href="http://www-cs-students.stanford.edu/~amitp/">About</a></li>
          <li> </li>
          <li><input type="search" name="q" placeholder="Search" size="8"></li>
        </ul><input type="hidden" name="hq" value="site:www.redblobgames.com OR site:theory.stanford.edu/~amitp/ OR site:www-cs-students.stanford.edu/~amitp/ OR site:amitp.blogspot.com OR site:simblob.blogspot.com">
      </form>
    </nav>
  </header>
  <main>
    <section>
      <p>Graphics libraries provide line-drawing routines, sometimes with <a href="https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm">antialiasing</a><sup class="print-endnote">[1]</sup> and variable width. On a grid map, line drawing is useful for for visibility, the path of an arrow/bullet, and enemy AI. I sometimes see people adapting the Bresenham line drawing algorithm to draw lines on a grid (especially for roguelike games), but I prefer simpler algorithms. I’ll show the algorithms I use. I’m not a line-drawing expert so please let me know if there are better algorithms that are similarly simple.</p>
      <p>This is the code. The first section will explain how it works and the helper functions <code>round_point</code> and <code>lerp_point</code> and <code>diagonal_distance</code> (these are all short), and then the other sections will describe variants of the algorithm.</p>
      <div class="org-src-container">
        <pre class="src src-js"><span class="keyword">function</span> <span class="function-name">line</span>(<span class="variable-name">p0</span>, <span class="variable-name">p1</span>) {
    <span class="keyword">let</span> <span class="variable-name">points</span> = [];
    <span class="keyword">let</span> <span class="variable-name">N</span> = diagonal_distance(p0, p1);
    <span class="keyword">for</span> (<span class="keyword">let</span> <span class="variable-name">step</span> = 0; step &lt;= N; step++) {
        <span class="keyword">let</span> <span class="variable-name">t</span> = N === 0? 0.0 : step / N;
        points.push(round_point(lerp_point(p0, p1, t)));
    }
    <span class="keyword">return</span> points;
}
</pre>
      </div>
    </section>
    <section>
      <h2 id="interpolation"><span class="section-number"> 1  </span><span><a href="#interpolation">Linear interpolation</a></span><a class="anchor" href="#interpolation">#</a></h2>
      <p>This demo shows what grid locations should be marked if you’re drawing a line between two points.
        <strong>Try moving the endpoints around</strong>.
      </p>
      <div id="line-top"></div>
      <p>I find the easiest way to find these points is to use <em>linear interpolation</em>. Let’s see how that works.</p>
      <h3 id="interpolation-numbers"><span class="section-number"> 1.1. </span><span>Interpolating numbers</span><a class="anchor" aria-hidden="true" href="#interpolation-numbers">#</a></h3>
      <p>Here’s a simple (Javascript) helper function I’ll use:</p>
      <div class="org-src-container">
        <pre class="src src-js"><span class="keyword">function</span> <span class="function-name">lerp</span>(<span class="variable-name">start</span>, <span class="variable-name">end</span>, <span class="variable-name">t</span>) {
    <span class="keyword">return</span> start + t * (end-start);
}
</pre>
      </div>
      <p><u>L</u>inear int<u>erp</u>olation (“lerp”) gives you a number between two other numbers. When <code>t</code> = 0.0 you get the start point; when <code>t</code> = 1.0 you get the end point. <strong>Try setting t</strong>, the third parameter to lerp():</p>
      <pre>lerp(  0,   1, <span data-name="t0" data-format=".2f"></span>) = <span id="lerp1"></span>
lerp(  0, 100, <span data-name="t0" data-format=".2f"></span>) = <span id="lerp2"></span>
lerp(  3,   5, <span data-name="t0" data-format=".2f"></span>) = <span id="lerp3"></span>
lerp(  5,   3, <span data-name="t0" data-format=".2f"></span>) = <span id="lerp4"></span>
</pre>
      <p>In shaders, this function is called <a href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dx-graphics-hlsl-lerp"><code>lerp</code></a><sup class="print-endnote">[2]</sup> in DirectX and <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/mix.xhtml"><code>mix</code></a><sup class="print-endnote">[3]</sup> in OpenGL. It’s called <code>lerp</code> in Unity and Unreal.</p>
      <h3 id="interpolation-points"><span class="section-number"> 1.2. </span><span>Interpolating points</span><a class="anchor" aria-hidden="true" href="#interpolation-points">#</a></h3>
      <p>We can extend the idea of interpolation to work on points, by interpolating both the x and y coordinates. <strong>Try varying t</strong> = <span data-name="line-interpolation-t" data-format=".2f"></span>:</p>
      <div id="line-interpolation"></div>
      <p>Here’s the code to find point x,y between point p<sub>0</sub> = (x<sub>0</sub>,y<sub>0</sub>) and point p<sub>1</sub> = (x<sub>1</sub>,y<sub>1</sub>):</p>
      <div class="org-src-container">
        <pre class="src src-js"><span class="keyword">function</span> <span class="function-name">lerp_point</span>(<span class="variable-name">p0</span>, <span class="variable-name">p1</span>, <span class="variable-name">t</span>) {
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Point</span>(lerp(p0.x, p1.x, t),
                     lerp(p0.y, p1.y, t));
}
</pre>
      </div>
      <p>Let’s divide the line into <span data-name="line-midpoints-N" data-format=".0f"></span> equal line segments:</p>
      <div id="line-midpoints"></div>
      <p>Here’s the code to find those points:</p>
      <div class="org-src-container">
        <pre class="src src-js"><span class="keyword">let</span> <span class="variable-name">points</span> = [];
<span class="keyword">for</span> (<span class="keyword">let</span> <span class="variable-name">step</span> = 0; step &lt;= N; step++) {
    <span class="keyword">let</span> <span class="variable-name">t</span> = step / N;
    points.push(lerp_point(p0, p1, t));
}
</pre>
      </div>
      <p>Variant: we can replace <kbd>step &lt;= N</kbd> with another condition, such as stopping at a wall or at the edge of the map.</p>
      <h3 id="snap-to-grid"><span class="section-number"> 1.3. </span><span>Snap to grid</span><a class="anchor" aria-hidden="true" href="#snap-to-grid">#</a></h3>
      <p>Next we need to figure out which <em>grid squares</em> those points are in. We can round x and y to the nearest integer to find the grid tile:</p>
      <div id="line-rounding"></div>
      <p>We also need to decide how many points to include. Too few and the line has holes. Too many and the line has overdraw. How many do we need? The right number is the <em>diagonal distance</em> between the endpoints, which in this case is <span class="line-rounding-distance"></span>.</p>
      <p><strong>Adjust N</strong> = <span data-name="line-rounding-N" data-format=".0f"></span> to <span class="line-rounding-distance"></span> to see how the line fills in. <span class="line-rounding-N-is-correct" style="color:green"></span></p>
      <p>That’s it!</p>
      <ol class="org-ol">
        <li>Set N to the diagonal distance between the start and end point.</li>
        <li>Pick N+1 interpolation points, evenly spaced.</li>
        <li>Round those points to the nearest grid tile.</li>
      </ol>
      <p>Here’s the final code:</p>
      <div class="org-src-container">
        <pre class="src src-js"><span class="keyword">function</span> <span class="function-name">line</span>(<span class="variable-name">p0</span>, <span class="variable-name">p1</span>) {
    <span class="keyword">let</span> <span class="variable-name">points</span> = [];
    <span class="keyword">let</span> <span class="variable-name">N</span> = diagonal_distance(p0, p1);
    <span class="keyword">for</span> (<span class="keyword">let</span> <span class="variable-name">step</span> = 0; step &lt;= N; step++) {
        <span class="keyword">let</span> <span class="variable-name">t</span> = N === 0? 0.0 : step / N;
        points.push(round_point(lerp_point(p0, p1, t)));
    }
    <span class="keyword">return</span> points;
}
</pre>
      </div>
      <p>This is the simplest line drawing algorithm I know of. Here are the helper functions, which you may have already implemented:</p>
      <div class="org-src-container">
        <pre class="src src-js"><span class="keyword">function</span> <span class="function-name">diagonal_distance</span>(<span class="variable-name">p0</span>, <span class="variable-name">p1</span>) {
    <span class="keyword">let</span> <span class="variable-name">dx</span> = p1.x - p0.x, <span class="variable-name">dy</span> = p1.y - p0.y;
    <span class="keyword">return</span> Math.max(Math.abs(dx), Math.abs(dy));
}

<span class="keyword">function</span> <span class="function-name">round_point</span>(<span class="variable-name">p</span>) {
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Point</span>(Math.round(p.x), Math.round(p.y));
}

<span class="keyword">function</span> <span class="function-name">lerp_point</span>(<span class="variable-name">p0</span>, <span class="variable-name">p1</span>, <span class="variable-name">t</span>) {
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Point</span>(lerp(p0.x, p1.x, t),
                     lerp(p0.y, p1.y, t));
}

<span class="keyword">function</span> <span class="function-name">lerp</span>(<span class="variable-name">start</span>, <span class="variable-name">end</span>, <span class="variable-name">t</span>) {
    <span class="keyword">return</span> start + t * (end-start);
}
</pre>
      </div>
      <h3 id="interpolation-other"><span class="section-number"> 1.4. </span><span>Interpolating other types</span><a class="anchor" aria-hidden="true" href="#interpolation-other">#</a></h3>
      <p>I defined the <code>lerp</code> function to interpolate between two <em>numbers</em>, and then I defined <code>lerp_point</code> to work on two <em>points</em>. How about other types <em>T</em>? We need these operations to define interpolation:</p>
      <dl class="org-dl">
        <dt>addition</dt>
        <dd>b = a + d where a: <em>T</em>, b: <em>T</em>, and d: <em>ΔT</em>. For points, b.x = a.x + d.x; b.y = a.y + d.y</dd>
        <dt>subtraction</dt>
        <dd>d = a - b where a: <em>T</em>, b: <em>T</em>, and d: <em>ΔT</em>. For points, d.x = a.x - b.x; d.y = a.y - b.y</dd>
        <dt>multiplication by scalar</dt>
        <dd>e = k * d where d: <em>ΔT</em>, e: <em>ΔT</em>, and k: <em>number</em>. For points, e.x = k * d.x; e.y = k * d.y</dd>
      </dl>
      <p>We can do interpolation on any <a href="http://en.wikipedia.org/wiki/Vector_space">vector space</a><sup class="print-endnote">[4]</sup>. <em>T</em> can be a number, a 2d point, a 3d point, an angle, a time, a color, or other things too. My <a href="http://www.redblobgames.com/grids/hexagons/#line-drawing">guide to hexagonal grids</a><sup class="print-endnote">[5]</sup> uses interpolation to draw lines on a hex grid. Note that <em>T</em> and <em>ΔT</em> may be the same type, but sometimes they are different. For example, <em>T</em> may be a timestamp and <em>ΔT</em> may be a time difference, or <em>T</em> may be an orientation and <em>ΔT</em> may be a rotation. When <em>T</em> and <em>ΔT</em> are the same type, d = a - b can be implemented as d = a + (-1 * b).</p>
      <h3 id="interpolation-aesthetics"><span class="section-number"> 1.5. </span><span>Aesthetics</span><a class="anchor" aria-hidden="true" href="#interpolation-aesthetics">#</a></h3>
      <p>Linear interpolation is calculating a position and then rounding it. What happens when the value is exactly 0.5? <a href="https://en.wikipedia.org/wiki/Rounding#Tie-breaking">Rounding rules vary</a><sup class="print-endnote">[6]</sup>. That, and floating point precision, make linear interpolation not always choose points in a way that preserves consistency with rotation, reversing, and other symmetry.</p>
      <p>I think the thing to do would be to “nudge” the initial points by epsilon. However I haven’t explored this with square grids. I’ve used it with hex grids.</p>
      <h3 id="optimization"><span class="section-number"> 1.6. </span><span>Code optimization</span><a class="anchor" aria-hidden="true" href="#optimization">#</a></h3>
      <p>You can optimize the regular line drawing algorithm with these steps; it will turn into the <a href="http://en.wikipedia.org/wiki/Digital_differential_analyzer_(graphics_algorithm)">DDA algorithm</a><sup class="print-endnote">[7]</sup>:</p>
      <dl class="org-dl">
        <dt>Inlining function calls</dt>
        <dd>Your compiler will likely do this but you may spot additional optimization opportunities by doing this yourself first.</dd>
        <dt>Unrolling lerp</dt>
        <dd>Instead of calculating t each time through the loop, and then x = (b.x-a.x)*t (a subtract and multiply), you can calculate Δx = (b.x-a.x)*Δt outside the loop, and then use x += Δx. Same for y. This will replace the multiplies with adds.</dd>
        <dt>Unrolling loop</dt>
        <dd>You can unroll the loop by keeping four x and y pairs, and then using t += 4*Δt. Would this allow the use of SSE instructions? I don’t know.</dd>
        <dt>Separate cases</dt>
        <dd>Either Δx or Δy will be ±1. You might want to have a separate versions for each case. For diagonal lines, both will be ±1. For orthogonal lines, one or the other will be 0. If these cases are common, write a separate routine for them.</dd>
        <dt>Floating point vs fixed point</dt>
        <dd>If you profile and find Math.round() is expensive, you can switch to fixed point arithmetic, and replace rounding with bit shifting. On x86, consider using the <code>fist=/=fistp</code> instruction or maybe SSE for <code>cvtsd2si</code> (I haven’t gone this far in optimization).</dd>
      </dl>
      <p>Before optimizing, profile and make sure linear interpolation is your bottleneck. In my projects, it rarely is, so I haven’t bothered implementing these optimizations. Here’s an example (in approximate C# syntax, to show the types) of inlining + unrolling lerp, but without applying the other optimizations:</p>
      <div class="org-src-container">
        <pre class="src src-csharp"><span class="type">List</span>&lt;<span class="type">Point</span>&gt; <span class="function-name">line</span>(<span class="type">Point</span> <span class="variable-name">p0</span>, <span class="type">Point</span> <span class="variable-name">p1</span>) {
    <span class="type">List</span>&lt;<span class="type">Point</span>&gt; = <span class="keyword">new</span> <span class="type">List</span>&lt;<span class="type">Point</span>&gt;();
    <span class="type">int</span> <span class="variable-name">dx</span> = p1.x - p0.x;
    <span class="type">int</span> <span class="variable-name">dy</span> <span class="type">int</span> = p1.y - p0.y;
    <span class="type">int</span> <span class="variable-name">N</span> = Math.<span class="function-name">Max</span>(Math.<span class="function-name">Abs</span>(dx), Math.<span class="function-name">Abs</span>(dy));
    <span class="type">float</span> <span class="variable-name">divN</span> = (N === 0)? 0.0 : 1.0 / N;
    <span class="type">float</span> <span class="variable-name">xstep</span> = dx * divN;
    <span class="type">float</span> <span class="variable-name">ystep</span> = dy * divN;
    <span class="type">float</span> <span class="variable-name">x</span> = p0.x, <span class="variable-name">y</span> = p0.y;
    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable-name">step</span> = 0; step &lt;= N; step++, x += xstep, y += ystep) {
        points.<span class="function-name">Add</span>(<span class="keyword">new</span> <span class="type">Point</span>(Math.<span class="function-name">Round</span>(<span class="type">x</span>), Math.<span class="function-name">Round</span>(<span class="type">y</span>));
    }
    <span class="keyword">return</span> points;
}
</pre>
      </div>
    </section>
    <section>
      <h2 id="stepping"><span class="section-number"> 2  </span><span><a href="#stepping">Grid walking</a></span><a class="anchor" href="#stepping">#</a></h2>
      <p>Interpolation is simple and general but doesn’t take into account properties of the grid. Another approach to line drawing is to take one step at a time. This type of movement also allows <em>putting walls on edges</em> so that a wall could block line of sight or movement.</p>
      <h3 id="orthogonal-steps"><span class="section-number"> 2.1. </span><span>Orthogonal steps</span><a class="anchor" aria-hidden="true" href="#orthogonal-steps">#</a></h3>
      <p>In the above lines, we took both orthogonal steps (north, east, south, west) and diagonal steps. Step-by-step algorithms give us more flexibility. What if we only want to take orthogonal steps?</p>
      <div id="diagram-grid-movement"></div>
      <p>The strategy here is to think about the <em>grid edges</em> being crossed, both vertical and horizontal. At every step we either cross a vertical edge (horizontal step) or cross a horizontal edge (vertical step). The way we can tell which way to go is by looking to see which of <code>(0.5+ix) / nx</code> and <code>(0.5+iy) / ny</code> is smaller. The smaller one is where we want to take the next step.</p>
      <div class="org-src-container">
        <pre class="src src-js"><span class="keyword">function</span> <span class="function-name">walk_grid</span>(<span class="variable-name">p0</span>, <span class="variable-name">p1</span>) {
    <span class="keyword">let</span> <span class="variable-name">dx</span> = p1.x-p0.x, <span class="variable-name">dy</span> = p1.y-p0.y;
    <span class="keyword">let</span> <span class="variable-name">nx</span> = Math.abs(dx), <span class="variable-name">ny</span> = Math.abs(dy);
    <span class="keyword">let</span> <span class="variable-name">sign_x</span> = dx &gt; 0? 1 : -1, <span class="variable-name">sign_y</span> = dy &gt; 0? 1 : -1;

    <span class="keyword">let</span> <span class="variable-name">p</span> = <span class="keyword">new</span> <span class="type">Point</span>(p0.x, p0.y);
    <span class="keyword">let</span> <span class="variable-name">points</span> = [<span class="keyword">new</span> <span class="type">Point</span>(p.x, p.y)];
    <span class="keyword">for</span> (<span class="keyword">let</span> <span class="variable-name">ix</span> = 0, <span class="variable-name">iy</span> = 0; ix &lt; nx || iy &lt; ny;) {
        <span class="keyword">if</span> ((0.5+ix) / nx &lt; (0.5+iy) / ny) {
            <span class="comment-delimiter">// </span><span class="comment">next step is horizontal</span>
            p.x += sign_x;
            ix++;
        } <span class="keyword">else</span> {
            <span class="comment-delimiter">// </span><span class="comment">next step is vertical</span>
            p.y += sign_y;
            iy++;
        }
        points.push(<span class="keyword">new</span> <span class="type">Point</span>(p.x, p.y));
    }
    <span class="keyword">return</span> points;
}
</pre>
      </div>
      <p>To avoid the division, including a potential divide by zero, we can rewrite the comparison from <code>(0.5+ix) / nx &lt; (0.5+iy) / ny</code> to <code>(0.5+ix) * ny &lt; (0.5+iy) * nx</code>. Then to avoid the floating point we can rewrite that to <code>(1 + 2*ix) * ny &lt; (1 + 2*iy) * nx</code>.</p>
      <p>It’s more work to make it symmetric. Also, sometimes you’ll want more control over whether you pick a horizontal step or a vertical step, especially if the choice is close, and there’s a wall in one direction but not the other.</p>
      <h3 id="supercover"><span class="section-number"> 2.2. </span><span>Supercover lines</span><a class="anchor" aria-hidden="true" href="#supercover">#</a></h3>
      <p>“Supercover” lines catch all the grid squares that a line passes through. I believe (but am not sure) that it is somewhere in between regular line drawing and grid movement line drawing. Unlike grid movement line drawing, we can take a diagonal step <em>only</em> if the line passes exactly through the corner.</p>
      <p>This looks like the grid movement line drawing, except when the line goes through a grid corner.</p>
      <div id="diagram-supercover"></div>
      <p>Let’s modify the grid movement line drawing code for this:</p>
      <div class="org-src-container">
        <pre class="src src-js"><span class="keyword">function</span> <span class="function-name">supercover_line</span>(<span class="variable-name">p0</span>, <span class="variable-name">p1</span>) {
    <span class="keyword">let</span> <span class="variable-name">dx</span> = p1.x-p0.x, <span class="variable-name">dy</span> = p1.y-p0.y;
    <span class="keyword">let</span> <span class="variable-name">nx</span> = Math.abs(dx), <span class="variable-name">ny</span> = Math.abs(dy);
    <span class="keyword">let</span> <span class="variable-name">sign_x</span> = dx &gt; 0? 1 : -1, <span class="variable-name">sign_y</span> = dy &gt; 0? 1 : -1;

    <span class="keyword">let</span> <span class="variable-name">p</span> = <span class="keyword">new</span> <span class="type">Point</span>(p0.x, p0.y);
    <span class="keyword">let</span> <span class="variable-name">points</span> = [<span class="keyword">new</span> <span class="type">Point</span>(p.x, p.y)];
    <span class="keyword">for</span> (<span class="keyword">let</span> <span class="variable-name">ix</span> = 0, <span class="variable-name">iy</span> = 0; ix &lt; nx || iy &lt; ny;) {
        <span class="keyword">let</span> <span class="variable-name">decision</span> = (1 + 2*ix) * ny - (1 + 2*iy) * nx;
        <span class="keyword">if</span> (decision === 0) {
            <span class="comment-delimiter">// </span><span class="comment">next step is diagonal</span>
            p.x += sign_x;
            p.y += sign_y;
            ix++;
            iy++;
        } <span class="keyword">else</span> <span class="keyword">if</span> (decision &lt; 0) {
            <span class="comment-delimiter">// </span><span class="comment">next step is horizontal</span>
            p.x += sign_x;
            ix++;
        } <span class="keyword">else</span> {
            <span class="comment-delimiter">// </span><span class="comment">next step is vertical</span>
            p.y += sign_y;
            iy++;
        }
        points.push(<span class="keyword">new</span> <span class="type">Point</span>(p.x, p.y));
    }
    <span class="keyword">return</span> points;
}
</pre>
      </div>
      <h3 id="line-of-sight"><span class="section-number"> 2.3. </span><span>Line of sight</span><a class="anchor" aria-hidden="true" href="#line-of-sight">#</a></h3>
      <p>If you allow diagonal steps, some algorithms will step through walls:</p>
      <figure><svg width="300" height="100">
          <g class="grid" transform="scale(50)">
            <rect x="0" y="0" width="0.95" height="0.95"></rect>
            <rect x="1" y="0" width="0.95" height="0.95" class="wall"></rect>
            <rect x="2" y="0" width="0.95" height="0.95"></rect>
            <rect x="3" y="0" width="0.95" height="0.95"></rect>
            <rect x="0" y="1" width="0.95" height="0.95"></rect>
            <rect x="1" y="1" width="0.95" height="0.95"></rect>
            <rect x="2" y="1" width="0.95" height="0.95" class="wall"></rect>
            <rect x="3" y="1" width="0.95" height="0.95"></rect>
            <path d="M 0.5,1.5 l 1,0 l 1,-1 l 0.7,0 m 0.3,0 l -0.3,-0.2 l 0,0.4 l 0.3,-0.2" fill="none" stroke="black" stroke-width="0.04"></path>
          </g>
        </svg></figure>
      <p>In this case, you can either take the diagonal step if <em>either</em> the horizontal or vertical step is clear, or you can disallow the diagonal step unless <em>both</em> the horizontal and vertical steps are clear.</p>
    </section>
    <section>
      <h2 id="more"><span class="section-number"> 3  </span><span><a href="#more">More reading</a></span><a class="anchor" href="#more">#</a></h2>
      <p>There’s lots written about line drawing but I haven’t researched it extensively. When drawing graphical lines, I use the graphics library. It’s only on grids that I needed to find some other algorithms.</p>
      <ul class="org-ul">
        <li>If you’re interpolating 3d rotations, look at the <a href="http://en.wikipedia.org/wiki/Slerp">slerp</a><sup class="print-endnote">[8]</sup> variant.</li>
        <li>If you want non-linear interpolation, take look at <a href="http://en.wikipedia.org/wiki/Smoothstep">smoothstep</a><sup class="print-endnote">[9]</sup> and <a href="http://inloop.github.io/interpolator/">others</a><sup class="print-endnote">[10]</sup>, especially for animation.</li>
        <li>Roguebasin has <a href="http://www.roguebasin.com/index.php?title%3DComparative_study_of_field_of_view_algorithms_for_2D_grid_based_worlds">an article</a><sup class="print-endnote">[11]</sup> about various qualities you might want on a grid if calculating field of view or line of sight.</li>
        <li><a href="http://www.cse.yorku.ca/~amana/research/grid.pdf">This paper</a><sup class="print-endnote">[12]</sup> gives an extension of the step-by-step line drawing algorithm for 3D coordinates.</li>
        <li><a href="http://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm">Wu’s algorithm</a><sup class="print-endnote">[13]</sup> for anti-aliasing might be useful for determining how much of an object is on one grid cell or another; I haven’t tried this.</li>
        <li><a href="https://hbfs.wordpress.com/2009/07/28/faster-than-bresenhams-algorithm/">This article</a><sup class="print-endnote">[14]</sup> looks at DDA line drawing with fixed point arithmetic. It’s from 2009 though and CPUs have changed since then. Also look at <a href="http://www.edepot.com/algorithm.html">Extremely Fast Line Algorithm</a><sup class="print-endnote">[15]</sup>.</li>
        <li>I find Bresenham’s algorithm to be much longer than I’d like, but if you’d like to compare, take a look at <a href="http://www.phatcode.net/res/224/files/html/ch35/35-03.html">Michael Abrash’s implementation</a><sup class="print-endnote">[16]</sup> and <a href="http://www.phatcode.net/res/224/files/html/ch35/35-01.html">explanation</a><sup class="print-endnote">[17]</sup>.</li>
      </ul>
      <!-- <script src="/js/d3.v3.min.js?2018-09-10-13-57-03"></script> -->
      <script ty_pe="module" src="linedrawing-helpers.js"></script>
      <script ty_pe="module" src="linedrawing.js"></script>
    </section>
  </main>
  <div class="below-divider">
    <p>Email me <a class="email" rel="me" href="mailto:redblobgames@gmail.com">redblobgames@gmail.com</a>, or tweet <a rel="me" href="https://twitter.com/redblobgames">@redblobgames</a>, or comment:</p>
    <div class="print-endnote">
      <h3>Endnotes</h3>
      <ol>
        <li>[1]: https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm</li>
        <li>[2]: https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dx-graphics-hlsl-lerp</li>
        <li>[3]: https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/mix.xhtml</li>
        <li>[4]: http://en.wikipedia.org/wiki/Vector_space</li>
        <li>[5]: http://www.redblobgames.com/grids/hexagons/#line-drawing</li>
        <li>[6]: https://en.wikipedia.org/wiki/Rounding#Tie-breaking</li>
        <li>[7]: http://en.wikipedia.org/wiki/Digital_differential_analyzer_(graphics_algorithm)</li>
        <li>[8]: http://en.wikipedia.org/wiki/Slerp</li>
        <li>[9]: http://en.wikipedia.org/wiki/Smoothstep</li>
        <li>[10]: http://inloop.github.io/interpolator/</li>
        <li>[11]: http://www.roguebasin.com/index.php?title%3DComparative_study_of_field_of_view_algorithms_for_2D_grid_based_worlds</li>
        <li>[12]: http://www.cse.yorku.ca/~amana/research/grid.pdf</li>
        <li>[13]: http://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm</li>
        <li>[14]: https://hbfs.wordpress.com/2009/07/28/faster-than-bresenhams-algorithm/</li>
        <li>[15]: http://www.edepot.com/algorithm.html</li>
        <li>[16]: http://www.phatcode.net/res/224/files/html/ch35/35-03.html</li>
        <li>[17]: http://www.phatcode.net/res/224/files/html/ch35/35-01.html</li>
      </ol>
    </div>
    <div class="comments" role="complementary">
      <div id="disqus_thread"><button style="padding:1em;width:100%" onclick="$disqus()">Load comments</button></div>
      <script>
        function disqus_config() { this.page.url = "http://www.redblobgames.com/grids/line-drawing.html" }

        function $disqus() {
          $disqus = () => {};
          $l("//redblobgames.disqus.com/embed.js")
        }
        if (document.location.hash.match(/#comment/)) setTimeout($disqus, 0)
        else if ('IntersectionObserver' in window) { new IntersectionObserver(e => { if (e[0].isIntersecting) $disqus() }).observe(document.getElementById('disqus_thread')) }
      </script><noscript><a href="//redblobgames.disqus.com/?url=https://www.redblobgames.com/grids/line-drawing.html">View the discussion thread.</a></noscript>
    </div>
  </div>
  <footer>
    <div>
      <address>
        Copyright © 2022
        <a rel="author home copyright" href="https://www.redblobgames.com/">Red Blob Games</a><br><a href="https://simblob.blogspot.com/feeds/posts/default"><svg viewBox="0 0 30 30" height="1em" style="vertical-align:text-bottom">
            <rect width="30" height="30" rx="5" fill="orange"></rect>
            <circle cx="7" cy="23" r="4" fill="white"></circle>
            <path d="M 5,5 A 20,20,0,0,1,25,25 M 5,13 A 12,12,0,0,1,17,25" fill="none" stroke="white" stroke-width="4" stroke-linecap="square"></path>
          </svg>RSS Feed</a>
      </address>
      <div>
         Created December 2014 with <a href="http://orgmode.org/">Emacs Org-mode</a>, from <a href="line-drawing.org">line-drawing.org</a>, and <a href="http://d3js.org/">D3.js</a>
         v3, and a mix of Typescript and Javascript. As much as possible, the algorithms presented are used to power the page.
        <!-- hhmts start -->Last modified: 27 May 2021
        <!-- hhmts end -->.
      </div>
    </div>
  </footer>
</body>

</html>
